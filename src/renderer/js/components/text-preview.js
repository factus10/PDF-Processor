// Text Preview Component
class TextPreviewComponent {
  constructor() {
    this.currentJobData = null;
    this.isVisible = false;
    this.initializeComponent();
  }

  initializeComponent() {
    // Initialize tabs
    this.setupTabSwitching();
    this.setupPreviewControls();
  }

  setupTabSwitching() {
    const tabButtons = document.querySelectorAll('.tab-btn');
    tabButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        const tabName = e.target.dataset.tab;
        this.switchTab(tabName);
      });
    });
  }

  setupPreviewControls() {
    const toggleBtn = document.getElementById('previewToggleBtn');
    if (toggleBtn) {
      toggleBtn.addEventListener('click', () => this.togglePreview());
    }

    const previewSelect = document.getElementById('previewSelect');
    if (previewSelect) {
      previewSelect.addEventListener('change', (e) => {
        this.loadJobPreview(e.target.value);
      });
    }
  }

  togglePreview() {
    const container = document.getElementById('previewContainer');
    const toggleBtn = document.getElementById('previewToggleBtn');
    
    if (!container || !toggleBtn) return;

    this.isVisible = !this.isVisible;
    
    if (this.isVisible) {
      container.style.display = 'block';
      container.classList.add('fade-in');
      toggleBtn.innerHTML = '<span class="icon">üëÅÔ∏è</span> Hide Preview';
    } else {
      container.style.display = 'none';
      toggleBtn.innerHTML = '<span class="icon">üëÅÔ∏è</span> Show Preview';
    }
  }

  switchTab(tabName) {
    // Update tab buttons
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    
    const activeBtn = document.querySelector(`[data-tab="${tabName}"]`);
    if (activeBtn) {
      activeBtn.classList.add('active');
    }

    // Update tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.remove('active');
    });
    
    const activeContent = document.getElementById(`${tabName}Tab`);
    if (activeContent) {
      activeContent.classList.add('active');
    }
  }

  updateJobList(jobs) {
    const previewSelect = document.getElementById('previewSelect');
    if (!previewSelect) return;

    // Clear existing options except the first one
    previewSelect.innerHTML = '<option value="">Select a processing job...</option>';

    // Add options for each job
    jobs.forEach((job, jobId) => {
      const option = document.createElement('option');
      option.value = jobId;
      option.textContent = this.truncateURL(job.url || `Job ${jobId}`, 50);
      previewSelect.appendChild(option);
    });
  }

  loadJobPreview(jobId) {
    if (!jobId) {
      this.clearPreview();
      return;
    }

    // In a real implementation, this would fetch the actual text data
    // For now, we'll show placeholder content
    this.showPlaceholderContent(jobId);
  }

  showPlaceholderContent(jobId) {
    const originalText = document.getElementById('originalText');
    const correctedText = document.getElementById('correctedText');
    const markdownText = document.getElementById('markdownText');

    if (originalText) {
      originalText.value = `Original OCR text for job ${jobId}...\n\nThis would contain the raw text extracted from the PDF pages before any corrections are applied. Text might contain OCR errors like:\n\n- Character substitutions (rn -> m)\n- Broken word boundaries\n- Column merging issues\n- Punctuation errors`;
    }

    if (correctedText) {
      correctedText.value = `Corrected text for job ${jobId}...\n\nThis would contain the text after applying:\n\n- OCR error corrections\n- Spell checking\n- Grammar improvements\n- Column layout restoration\n- Paragraph structure fixes`;
    }

    if (markdownText) {
      markdownText.value = `# Document Title\n\n## Introduction\n\nThis would contain the final Markdown output for job ${jobId} with:\n\n- **Proper heading structure**\n- *Text formatting*\n- List items\n- Link corrections\n- Table formatting\n\n### Features\n\n1. Intelligent heading detection\n2. List restoration\n3. Link preservation\n4. Table reconstruction\n\n---\n\n*Generated by PDF Processor*`;
    }
  }

  updatePreviewData(jobId, data) {
    const previewSelect = document.getElementById('previewSelect');
    if (previewSelect && previewSelect.value === jobId) {
      // Update preview if this job is currently selected
      if (data.originalText) {
        const originalText = document.getElementById('originalText');
        if (originalText) originalText.value = data.originalText;
      }

      if (data.correctedText) {
        const correctedText = document.getElementById('correctedText');
        if (correctedText) correctedText.value = data.correctedText;
      }

      if (data.markdownText) {
        const markdownText = document.getElementById('markdownText');
        if (markdownText) markdownText.value = data.markdownText;
      }
    }
  }

  clearPreview() {
    const textAreas = ['originalText', 'correctedText', 'markdownText'];
    textAreas.forEach(id => {
      const element = document.getElementById(id);
      if (element) element.value = '';
    });
  }

  truncateURL(url, maxLength) {
    if (!url || url.length <= maxLength) return url;
    return url.substring(0, maxLength - 3) + '...';
  }

  exportPreview() {
    const activeTab = document.querySelector('.tab-content.active textarea');
    if (!activeTab || !activeTab.value) {
      this.showNotification('No content to export', 'warning');
      return;
    }

    const content = activeTab.value;
    const tabType = activeTab.id.replace('Text', '');
    const filename = `preview_${tabType}_${Date.now()}.txt`;

    this.downloadText(content, filename);
  }

  downloadText(content, filename) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  showNotification(message, type) {
    // Simple notification (could be enhanced)
    console.log(`${type.toUpperCase()}: ${message}`);
  }
}

// Initialize component when DOM is ready
if (typeof window !== 'undefined') {
  document.addEventListener('DOMContentLoaded', () => {
    window.textPreviewComponent = new TextPreviewComponent();
  });
}